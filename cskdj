1.	Основные этапы эволюции интернет-технологий (Web 1.0, 2.0, 3.0). 
1. Web 1.0 – статический интернет. Это эпоха статического контента. Сайты представляли собой «электронные витрины» или библиотеки.
Технологии: простой HTML, фреймы, таблицы.
Роль пользователя: пассивный потребитель.
Примеры: страницы-визитки, статические каталоги.
2. Web 2.0 – социальный интернет (начало адаптивности). Эра социального интернета и пользовательского контента. Интернет стал платформой для взаимодействия.
Технологии: JavaScript, AJAX, CSS, адаптивный дизайн.
Роль пользователя: соавтор контента.
Примеры: соцсети (VK, YouTube), блоги, Wikipedia, Google Docs.
3. Web 3.0 – семантический интернет (децентрализация интернета, нативные мобильные приложения, ИИ). Машины начинают понимать смысл информации, а не только отображать её.
Технологии: ИИ, блокчейн, Big Data, микросервисы.
Роль пользователя: владелец своих данных.
Примеры: криптовалюты, dApps, смарт-контракты, умные ассистенты.
4. Web 4.0 – симбиотический интернет (развитие нейротехнологий/будущее). Этап максимально плотного взаимодействия человека и сети.
Технологии: нейроинтерфейсы, IoT, дополненная реальность.
Суть: Сеть предугадывает потребности человека на основе биологических и поведенческих данных.

2.	Характеристики эталонной сетевой модели OSI. Роль каждого уровня модели. Отличие модели TCP/IP от OSI.
Модель OSI (Open Systems Interconnection) — эталонная модель, описывающая 7 уровней взаимодействия сетевых протоколов. 
Роли уровней: 
1. Физический: Передача сырых битов (0 и 1) по физической среде (кабели, оптоволокно);
2. Канальный: доступ к среде и MAC-адресация. 
3. Сетевой: маршрутизация и IP-адресация 
4. Транспортный: Надежная доставка данных (TCP/UDP), управление потоком и исправление ошибок между приложениями.
5. Сеансовый: Установка, поддержка и завершение сеансов связи между приложениями.
6. Представления: Преобразование, шифрование и сжатие данных для приложений (форматы данных).
7. Прикладной: интерфейс для приложений (HTTP, FTP). 
Отличие TCP/IP от OSI: TCP/IP имеет 4 уровня (Канальный, Сетевой, Транспортный, Прикладной), она практичнее и лежит в основе интернета, в то время как OSI — теоретическая модель. 
3.	Роль протоколов IP, TCP, UDP и DNS в работе Интернета.
Эти протоколы обеспечивают базовое функционирование сети:
•	IP (Internet Protocol): Отвечает за адресацию и маршрутизацию. Позволяет устройствам находить друг друга по уникальным адресам (IPv4 или IPv6) и передавать пакеты данных между сетями.
•	TCP (Transmission Control Protocol): Протокол с гарантированной доставкой. Устанавливает надежное соединение («рукопожатие»), следит, чтобы все данные пришли в правильном порядке и без потерь. На нем работает HTTP (веб-страницы).
•	UDP (User Datagram Protocol): Протокол передачи без гарантии доставки. Работает быстрее TCP, так как не тратит время на проверку получения пакетов. Используется для потокового видео, звонков и DNS-запросов.
•	DNS (Domain Name System): «Телефонная книга» интернета. Переводит понятные человеку доменные имена (например, google.com) в IP-адреса, понятные компьютеру.

4.	Версии протокола IP: IPv4 и IPv6.
IPv4 использует 32-битные адреса (например, 192.168.1.1), что дает около 4.3 млрд адресов. Для экономии используется NAT (NAT (Network Address Translation) — это технология, которая заменяет внутренние IP-адреса на внешний, когда устройства локальной сети выходят в интернет. Проще говоря, NAT выступает посредником между внутренней сетью и глобальной сетью: принимает запросы от компьютеров, смартфонов и телевизоров, а затем отправляет их в интернет от имени одного общего адреса.). 
IPv6 использует 128-битные адреса (например, 2001:0db8::), что обеспечивает практически неограниченное количество адресов, а также улучшенную безопасность и маршрутизацию.
 
5.	Базовые сетевые устройства: концентратор, коммутатор, маршрутизатор.
Различие устройств заключается в «интеллекте» и уровне модели OSI, на котором они работают:
•	Концентратор (Hub): Самое простое устройство (физический уровень L1). Принимает сигнал на один порт и тупо копирует его на все остальные порты. Это создает много лишнего трафика.
•	Коммутатор (Switch): Более умное устройство (канальный уровень L2). Знает MAC-адреса подключенных устройств и передает данные только конкретному получателю, а не всем подряд. Используется для создания локальной сети (LAN).
•	Маршрутизатор (Router): Самое умное устройство (сетевой уровень L3). Работает с IP-адресами. Умеет пересылать пакеты между разными сетями (например, между вашей домашней сетью и интернетом), выбирая оптимальный маршрут.


6.	Понятия пакета, кадра, сегмента при обмене данными в сети.
В модели OSI понятия пакета, кадра, сегмента – это все передача данных на разных уровнях и в разных форматах.

Физический, Канальный, Сетевой, Транспортный, Сеансовый, Представления, Прикладной. 
Пакет – единица данных сетевого уровня (содержит IP-адреса). IP-заголовок (IP-адреса отправителя и получателя, информация для маршрутизации).
Кадр – единица данных канального уровня (обрамляет пакет. заголовок- MAC-адреса отправителя и получателя, контрольные данные.
Сегмент – единица данных транспортного уровня (содержит порты и управляющую информацию). Заголовок транспорта (порты отправителя и получателя, контрольные номера, флаги).
7.	Стандарты SGML, HTML и XML. Основные отличия HTML от XML.
SGML (Standard Generalized Markup Language) — международный стандарт (ISO, 1986), позволяющий описывать структуру и синтаксис документов с помощью декларации DTD. Является прообразом HTML и XML.
HTML (HyperText Markup Language) — язык разметки, использующий семантический подход для структурирования содержимого. Версия 1.0 выпущена в 1991 году.
XML (eXtensible Markup Language) — утвержден W3C в 1998 году. Широко применяется для обмена данными и структурами (например, с сервером), а также хранения параметров настройки программ.
Отличие: HTML предназначен для разметки и отображения данных веб-страницы, тогда как XML используется для хранения и передачи структурированных данных.
8.	Эволюция языка разметки гипертекста HTML (до HTML5).
HTML 1.0 (1991): базовые статические страницы. Основные теги: <p>, <h1>–<h6>, <a>, <ul>, <li>. Не было изображений, таблиц, форм. Веб-страницы были чисто статическими, без дизайна.
HTML 2.0 (1995): стандартизация, появление форм. Ключевое нововведение — формы (<form>, <input>), что стало началом интерактивности в вебе. 
HTML 3.2 (1997): поддержка таблиц, JavaScript, CSS. Основные нововведения: официальная поддержка таблиц (<table>, <tr>, <td>). Началась эпоха более сложного визуального оформления.
HTML 4.01 (1999): разделение структуры и представления, семантический подход. Переломный момент. Главная философия — разделение структуры документа (HTML) и его представления (CSS). Эта версия заложила основы современной вёрстки. 
XHTML (2000): строгий синтаксис на основе XML. Но не новая функциональность, а переформулировка HTML 4.01 как приложения XML.
HTML5 (2014 — живая спецификация): нативные мультимедиа, семантические теги, API для веб-приложений. Ключевые черты: новые семантические теги , нативная поддержка мультимедиа без плагинов, графика и векторная анимация, мощные JavaScript API для работы с геолокацией, локальным хранилищем, файлами, графикой, сетевыми соединениями.
9.	Структура HTML-документа. 
Базовая структура HTML-документа включает:
•	Декларацию типа документа: <!DOCTYPE html>.
•	Корневой тег <html> с указанием языка (например, lang="ru").
•	Секцию <head>, содержащую метаданные (кодировку meta charset, заголовок title).
•	Секцию <body>, содержащую видимый контент страницы (заголовки, параграфы, скрипты).
Пример 
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Моя первая веб-страница</title>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это мой первый абзац на HTML.</p>
</body>
</html>

10.	Блочные и строчные элементы HTML.
Блочные элементы занимают всю доступную ширину, начинаются с новой строки. Примеры: <div>, <p>, <h1-h6>, <ul>, <section>. 
Строчные элементы занимают только ширину содержимого, не переносятся на новую строку. Примеры: span, a, strong, img, input. Блочным можно задавать ширину/высоту и отступы, на строчные это влияет ограниченно.
11.	Понятие семантической верстки. Примеры семантических тегов, их значение.
Семантическая верстка — это подход к созданию HTML-кода, где используются теги, отражающие смысл содержимого (например, <header>, <nav>, <article>), а не только его внешний вид, что улучшает доступность для пользователей и понимание структуры страницы поисковыми системами и браузерами, облегчая индексацию и масштабирование сайта. Вместо безликих <div> применяются теги, четко описывающие роль контента (шапка, навигация, основной текст, футер). 

Семантический подход (внедрен в HTML 4) подразумевает разделение содержимого по смыслу.
•	Семантические теги — это теги, описывающие смысловое назначение содержимого, а не его внешний вид.
•	Примеры тегов (появились в HTML 5): header (шапка), footer (подвал), main (основное содержимое), nav (навигация), article (статья), section (раздел).

12.	Эволюция формального языка описание стилей CSS (до CSS3).
CSS1 (1996): Основа. Шрифты, цвета, простые отступы (margin/padding), базовые селекторы (тег, класс, id).

CSS2 (1998): Позиционирование (absolute, relative, fixed), медиа-типы (@media), расширенные селекторы (дочерние, атрибутные), z-index.

CSS2.1 (2011): Исправленная и стабильная версия CSS2. Убраны неподдерживаемые функции.

CSS3 (модули с 1999): Модульный подход. Ключевые новшества:
- Новые селекторы (:nth-child, :not)
- Скругления, тени, градиенты
- Веб-шрифты (@font-face)
- Медиа-запросы (основа адаптивного дизайна)
- Анимации (transform, transition, @keyframes)
- Flexbox и Grid для сложной вёрстки

13.	Принцип каскадирования и наследования в CSS. Структура CSS-записи.
Каскадирование: Механизм разрешения конфликтов, когда к одному элементу применяется несколько стилей. Браузер выбирает стиль с наивысшим приоритетом (весом). Приоритет зависит от источника стиля (браузер, пользователь, автор), специфичности селектора (ID сильнее класса) и порядка подключения (последнее правило перекрывает предыдущие).
Наследование: Механизм, при котором дочерние элементы автоматически перенимают определенные свойства родителя (например, если задать font-family для body, весь текст внутри него унаследует этот шрифт). Свойства вроде border или margin обычно не наследуются.
Структура CSS-записи:
CSS
Селектор {
    Свойство: Значение;
}
/* Пример: */
p {
    color: red;
}
14.	Внутренний, встроенный и внешний CSS.
Внешний CSS: стили в отдельном файле .css, подключаются через тег link в head. (<link rel="stylesheet" href="css/style.css">)
Внутренний CSS: стили внутри тега style в секции head документа. Встроенный CSS: стили в атрибуте style HTML-элемента. Рекомендуется использовать внешние стили для удобства поддержки.
15.	Боксовая модель CSS.
Каждый элемент в HTML рассматривается браузером как прямоугольный ящик. Боксовая модель описывает структуру этого ящика (от центра к краям):
1.	Content (Контент): Само содержимое элемента (текст, картинка).
2.	Padding (Внутренний отступ): Прозрачное поле между контентом и рамкой.
3.	Border (Рамка): Граница, идущая вокруг паддинга.
4.	Margin (Внешний отступ): Пустое пространство снаружи рамки, отделяющее элемент от соседей.


16.	Методы позиционирования элементов на странице.
static: элемент в потоке документа (по умолчанию). 
relative: позиционирование относительно своего обычного места. 
absolute: позиционирование относительно ближайшего позиционированного предка, элемент извлекается из потока. 
fixed: позиционирование относительно окна браузера, элемент прилипает при прокрутке. 
sticky: гибрид relative и fixed, элемент липнет при достижении порога прокрутки.
17.	Элементы формы и их свойства. Регулярные выражения для проверки валидности данных.
Элементы формы: Для создания анкет используются теги <form>, внутри которых располагаются поля ввода <input> различных типов: text (текст), date (дата), radio (переключатель), tel (телефон), email (почта), а также кнопки <button type="submit">.
Свойства (атрибуты):
•	required — делает поле обязательным.
•	placeholder — текстовая подсказка в поле.
•	pattern — устанавливает шаблон для проверки данных (валидации).
Регулярные выражения: Используются для создания шаблонов проверки. Пример шаблона для кириллицы: ^[А-Яа-яЁё\s]+$. Метасимволы позволяют описывать сложные правила (например, \d для цифр).

18.	Объектная модель документа (DOM). JavaScript как средство взаимодействия с DOM-деревом.
DOM — Document Object Model — программный интерфейс, представляющий HTML-документ в виде древовидной структуры объектов. 
JavaScript позволяет динамически изменять DOM: искать элементы (getElementById, querySelector), изменять содержимое и стили (innerHTML, style), создавать и удалять элементы (createElement, removeChild), обрабатывать события (addEventListener). Это делает страницы интерактивными.


19.	Концепции JavaScript: типы данных, переменные, ключевые языковые коснтрукции.
Переменные: Контейнеры для хранения данных. Объявляются через let (изменяемая), const (постоянная) или var (устаревшая).
Типы данных:
•	Примитивы: Number (числа), String (строки), Boolean (true/false), Null, Undefined.
•	Объекты: Сложные структуры данных, массивы.
Ключевые конструкции:
•	Условные операторы: if (условие) { ... } else { ... } — используются для валидации форм (например как в 3 лабораторной, проверка возраста).
•	Циклы: for, while — для повторения действий.
•	Функции: Блоки кода, которые можно вызывать повторно.
•	События: Реакция на действия (например, onclick, onsubmit).

20.	Обработчик событий в JavaScript. Примеры распространенных событий.
Обработчик события — функция, выполняемая при наступлении события. Назначается через addEventListener (рекомендуется), через свойство элемента (onclick) или атрибут HTML. 
Примеры событий: мыши (click, mouseover), клавиатуры (keydown, keyup), формы (submit, change), окна (load, resize).
21.	Концепция клиент-серверной архитектуры применительно к веб. 
Клиент-серверная архитектура — это распределенная вычислительная модель, при которой:
•	Клиент (устройство) запрашивает ресурсы у сервера.
•	Сервер обрабатывает запросы и предоставляет данные.





22.	Роли клиента, веб-сервера, базы данных и СУБД.
Клиент (браузер) отправляет запросы и отображает интерфейс ¬ (т.е. пользовательский интерфейс веб-страницы — всё то, что видит и с чем взаимодействует пользователь.) 
Веб-сервер (Apache, Nginx) принимает HTTP-запросы и возвращает статический контент или передает запросы backend-приложению. Серверное приложение (PHP, Python) выполняет логику и генерирует динамический контент. 
СУБД (MySQL) управляет базой данных, выполняя запросы на чтение/запись. База данных хранит информацию в структурированном виде.

23.	Роль протокола HTTP при обмене данными с веб-сервером. Структура HTTP-cообщения.
HTTP (HyperText Transfer Protocol) — протокол прикладного уровня, работающий по модели «запрос-ответ». Он обеспечивает клиент-серверное взаимодействие, где браузер запрашивает информацию, а сервер ее предоставляет в структурированном формате
Структура HTTP-сообщения представляет собой набор пар «ключ-значение» и включает:
1.	Стартовую строку: 
Для запроса: Метод + URI + Версия HTTP (например, GET /index.html HTTP/1.1).
Для ответа: Версия HTTP + Код состояния + Пояснение (например, HTTP/1.1 200 OK)
2.	Заголовки: 
Headers: Пары ключ-значение, делятся на категории (общие, запроса, ответа).
Host: адрес сервера.
User-Agent: информация о браузере клиента.
Content-Type: тип передаваемых данных (например, application/x-www-form-urlencoded для форм или text/html).
Cookie: данные для идентификации сессии пользователя.
3.	Пустую строку-разделитель.
4.	Тело сообщения (Body): Может быть пустым или содержать данные (например, JSON или данные формы).

24.	Классификация HTTP-методов.
GET — используется для получения данных о ресурсе с сервера.
HEAD — аналогичен GET, но сервер возвращает только заголовки без тела ответа.
POST — применяется для отправки данных на сервер, например для создания или изменения ресурса.
PUT — полностью заменяет существующий ресурс данными, переданными в запросе.
DELETE — удаляет указанный ресурс.
CONNECT — устанавливает защищённый туннель между клиентом и сервером (часто через прокси).
OPTIONS — запрашивает у сервера информацию о доступных методах и параметрах взаимодействия.
TRACE — возвращает запрос обратно клиенту для отслеживания пути его прохождения.
PATCH — вносит частичные изменения в ресурс без его полной замены.

25.	Принципиальные различия между методами GET и POST с точки зрения передачи данных и безопасности.
Передача данных
•	GET передаёт данные через URL в формате ключ=значение, имеет ограничение на длину и используется для получения данных без изменения состояния сервера.
•	POST передаёт данные в теле запроса, не имеет ограничений по объёму и применяется для отправки форм, загрузки файлов, создания или изменения ресурсов.
Безопасность
•	GET не подходит для конфиденциальных данных, так как информация видна в URL, сохраняется в истории браузера, кэше и логах сервера.
•	POST более безопасен, поскольку данные не отображаются в URL, однако не обеспечивает шифрование. Для защиты информации необходимо использовать HTTPS, который шифрует весь трафик. Без HTTPS данные обоих методов могут быть перехвачены.
26.	Классификация и назначение кодов состояния HTTP-ответов.
1xx: Информационные (запрос обрабатывается). 
2xx: Успех (200 OK, 201 Created). 
3xx: Перенаправление (301 Moved Permanently, 304 Not Modified). 
4xx: Ошибка клиента (400 Bad Request, 404 Not Found). 
5xx: Ошибка сервера (500 Internal Server Error, 503 Service Unavailable).

("хх" здесь означает две любые цифры — это шаблон обозначения.)

•	400 Bad Request (Плохой запрос) — Сервер не понял синтаксис запроса из-за неверного формата. Частая причина — ошибка в коде фронтенда или битые данные формы.
•	401 Unauthorized (Не авторизован) — Для доступа к ресурсу требуется аутентификация (ввод логина/пароля). Заголовок WWW-Authenticate должен содержать информацию о типе авторизации.
•	403 Forbidden (Запрещено) — Сервер понял запрос, но отказывается его выполнять из-за недостаточных прав у пользователя (даже если он авторизован). Чаще — ошибка в настройках прав доступа на сервере (например, к файлу .htaccess или папке).
•	404 Not Found (Не найдено) — Самый известный код. Сервер не нашел запрашиваемый ресурс (страницу, файл, изображение). URL может быть неправильным, или ресурс был удален.
•	405 Method Not Allowed (Метод не разрешен) — Запрос был сделан с методом (GET, POST и т.д.), который не поддерживается для данного URL. Например, попытка отправить POST на страницу, которая принимает только GET.
•	408 Request Timeout (Истекло время ожидания запроса) — Сервер не дождался полного запроса от клиента в отведенное время. Сетевая проблема или клиент слишком медленный.
•	429 Too Many Requests (Слишком много запросов) — Клиент отправил слишком много запросов за короткий промежуток времени (часть защиты от DDoS или ограничения API).
________________________________________
5хх — Ошибки сервера (Server Error)
Ошибки, возникающие по вине сервера. Сервер столкнулся с ситуацией, которая не позволяет ему выполнить корректный запрос клиента.
Основные коды:
•	500 Internal Server Error (Внутренняя ошибка сервера) — Общий статус для неожиданных сбоев, когда сервер не может определить более конкретную причину. Частые причины: ошибки в коде серверного приложения (PHP, Python), синтаксические ошибки, сбой в конфигурации.
•	501 Not Implemented (Не реализовано) — Сервер не поддерживает функциональность, необходимую для выполнения запроса (например, неизвестный метод HTTP).
•	502 Bad Gateway (Плохой шлюз) — Сервер, выступая в роли шлюза или прокси, получил недопустимый ответ от вышестоящего сервера. Частая проблема при сбое бэкенд-сервиса (например, PHP-FPM) или неправильной конфигурации прокси (Nginx/Apache).
•	503 Service Unavailable (Сервис недоступен) — Сервер временно не может обрабатывать запросы из-за перегрузки или планового технического обслуживания. Ответ может включать заголовок Retry-After с указанием времени, когда сервер снова будет доступен.
•	504 Gateway Timeout (Шлюз не отвечает) — Сервер, выступая в роли шлюза или прокси, не дождался ответа от вышестоящего сервера в отведенное время. Проблема в медленной работе или недоступности бэкенд-сервиса.
•	505 HTTP Version Not Supported (Версия HTTP не поддерживается) — Сервер не поддерживает версию протокола HTTP, указанную в запросе.
Краткая памятка:
•	4хх (4 — "Клиент"): Вы (или ваш код) что-то сделали неправильно. Проверяйте URL, права доступа, правильность отправляемых данных.
•	5хх (5 — "Сервер"): Проблема на стороне сервера. Как пользователь вы мало что можете сделать, кроме как повторить попытку позже. Как разработчик — нужно проверять логи сервера и работоспособность бэкенда.

27.	Основные синтаксические конструкции языка PHP.
Основные конструкции включают:
•	Переменные: Начинаются с символа $ (например, $name = "Иван";).
•	Типы данных: String, Integer, Float, Boolean, Array (индексированные и ассоциативные).
•	Вывод данных: echo, print_r, var_dump.
•	Операторы: Арифметические (+, -, *, /, %, **), сравнения (==, !=, >, ===), строковые (.) .
•	Условные операторы: if-elseif-else, switch-case .
•	Циклы: for, while, foreach (для массивов) .
•	Функции: Объявляются через function name($arg) { ... return ... }.

28.	Порядок установки WampServer. Основные директории WampServer.
WampServer — это платформа для веб-разработки под Windows, включающая: W — Windows (операционная система); A — Apache (веб-сервер); M — MySQL (система управления базами данных); P — PHP (серверный язык программирования).

Установка: скачать установщик, запустить от администратора, следовать шагам мастера, выбрать директорию и настройки, завершить установку. 
Основные директории в C:\wamp64: www/ (файлы проектов), bin/ (исполняемые файлы Apache, MySQL, PHP), logs/ (логи), alias/ (файлы для алиасов).
29.	Возможности приложения phpMyAdmin в контексте настройки и администрирования веб-сервера. 
phpMyAdmin позволяет через графический интерфейс:
•	Создавать базы данных и таблицы с настройкой полей (типы, первичные ключи, автоинкремент).
•	Управлять учетными записями пользователей: добавлять пользователей, задавать имена хостов и пароли .
•	Назначать привилегии (права доступа) пользователям: глобальные или на уровне конкретной БД (например, SELECT, INSERT, UPDATE).
•	Выполнять SQL-запросы напрямую во вкладке SQL.

30.	Понятие реляционной модели данных. Структура реляционной базы данных.
Реляционная модель представляет данные в виде набора взаимосвязанных таблиц. Структура: Таблица (сущность), состоящая из строк (записей) и столбцов (полей). Первичный ключ (PK) уникально идентифицирует запись. Внешний ключ (FK) связывает таблицы, ссылаясь на первичный ключ другой таблицы.
31.	Типы полей реляционной БД. Свойство аутоинкремент.
Типы полей:
•	INT — целое число.
•	VARCHAR(n) — строка переменной длины (до n символов).
•	TEXT — для больших текстовых данных.
•	DATE, DATETIME, TIMESTAMP — дата и время.
•	DECIMAL(m, n) — число с фиксированной точностью (для цен).
•	BOOLEAN — логический тип (TRUE/FALSE).
•	ENUM — перечисление из списка значений.
Аутоинкремент (Auto Increment): Свойство поля (обычно первичного ключа), при котором БД автоматически присваивает ему уникальное последовательное целое число, увеличивающееся на 1 при добавлении новой записи. Это гарантирует уникальность идентификатора.



32.	Ключевое поле таблицы. Виды ключей в таблицах БД.
В реляционных базах данных выделяют несколько видов ключей: 
Первичный ключ (Primary Key, PK) — уникальный идентификатор записи в таблице. Значение PK не может быть NULL и должно быть уникальным. (например, product_id). 
Внешний ключ (Foreign Key, FK) — поле в одной таблице, которое ссылается на первичный ключ в другой таблице. Внешний ключ обеспечивает целостность ссылочных данных: нельзя будет добавить запись со ссылкой на несуществующую запись в главной таблице. 
Потенциальный ключ (Candidate Key) — поле или комбинация полей, которые могут быть выбраны в качестве первичного ключа (например, email в таблице Клиенты). 
Составной ключ (Composite Key) — первичный ключ, состоящий из двух или более полей.
33.	Способы и виды связей между сущностями.
В реляционных БД выделяют следующие типы связей:
1.	Один-ко-многим (1:N): Одной записи в таблице А соответствует несколько записей в таблице Б. Реализуется через внешний ключ в таблице «многих» .
2.	Многие-ко-многим (M:N): Нескольким записям в таблице А соответствуют несколько записей в таблице Б. Реализуется через промежуточную таблицу-связку с внешними ключами .
3.	Один-к-одному (1:1): Одной записи в таблице А соответствует не более одной записи в таблице Б (используется реже, например, для безопасности) .
4.	Рекурсивная связь: Сущность связана сама с собой (например, сотрудник и его начальник в одной таблице).

34.	Распределение прав доступа к базе данных. Роли и привилегии. Управление привилегиями в phpMyAdmin.
Управление доступом необходимо для обеспечения безопасности данных. Управление строится на принципе наименьших привилегий: пользователь должен иметь доступ только к тем данным и операциям, которые необходимы для его работы. При распределении прав можно выделить следующие понятия: 
- Пользователь (User) — учетная запись для подключения к СУБД. 
- Роль (Role) — именованный набор привилегий. Роли назначаются пользователям, что упрощает управление правами для групп пользователей с одинаковыми функциями. 
- Привилегия (Privilege) — право на выполнение определенной операции. Привилегии бывают глобальные, например, действия CREATE USER, SHUTDOWN (для администраторов); уровня базы данных, например, действия CREATE, DROP (для разработчиков); уровня таблицы, например, SELECT (чтение), INSERT (добавление), UPDATE (изменение), DELETE (удаление). Привилегии уровня столбца: можно дать право, например, на UPDATE только для определенного столбца.

35.	Назначение языка запросов SQL. Типы команд языка.
SQL (Structured Query Language) — декларативный язык программирования для работы с реляционными базами данных. Команды делятся на типы:
•	DDL (Data Definition Language): Определение структуры данных (создание, изменение, удаление таблиц/БД).
•	DML (Data Manipulation Language): Управление данными (вставка, удаление, обновление).
•	DQL (Data Query Language): Формирование запросов (выборка, фильтрация, сортировка).
•	DCL (Data Control Language): Управление доступом.
•	DTL: Управление транзакциями.

36.	Основные операции языка SQL: SELECT, INSERT, UPDATE, DELETE.
SELECT: выборка данных (SELECT * FROM table). 
INSERT: добавление записи (INSERT INTO table (col) VALUES (val)). 
UPDATE: обновление записи (UPDATE table SET col=val WHERE id=1). DELETE: удаление записи (DELETE FROM table WHERE condition).
37.	Работа с условными запросами в SQL. Использование логическими операторами и операторами сравнения.
Для фильтрации данных в SQL используется оператор WHERE.
•	Операторы сравнения: Позволяют сравнивать значения полей.
o	= (равно), <> или != (не равно).
o	>, <, >=, <= (больше, меньше и т.д.).
o	LIKE (поиск по шаблону, например, имен на букву "А").
•	Логические операторы: Объединяют несколько условий.
o	AND (И) — строка выбирается, если верны оба условия (пример: цена > 1000 И в наличии).
o	OR (ИЛИ) — строка выбирается, если верно хотя бы одно условие.
o	NOT (НЕ) — инвертирует условие (пример: NOT NULL — поле не пустое).

38.	Роль DNS в работе Интернета. Цепочка взаимодействия технологий при запросе сайта.
DNS преобразует доменные имена (site.com) в IP-адреса. 
Цепочка запроса: 
1) Ввод адреса в браузере. 
2) Запрос к DNS-резолверу. 
3) Рекурсивный запрос к корневым серверам, TLD-серверам, авторитативным серверам домена. 
4) Получение IP-адреса. 
5) Установка TCP-соединения с сервером. 
6) Отправка HTTP-запроса (GET). 
7) Получение HTTP-ответа с данными страницы. 
8) Отрисовка страницы браузером.
39.	DNS-запись. Основные типы DNS-записей: A, AAAA, CNAME, MX, TXT, NS. Назначение каждой из них.
DNS-записи определяют соответствие доменных имен IP-адресам и служебной информации. Основные типы:
•	A-запись: Связывает домен с IPv4-адресом.
•	AAAA-запись: Связывает домен с IPv6-адресом.
•	CNAME-запись: Создает псевдоним (алиас) для домена.
•	MX-запись: Указывает почтовый сервер для домена.
•	TXT-запись: Содержит текстовую информацию.
•	NS-запись: Указывает на DNS-серверы, обслуживающие домен.

40.	Доменное имя. Иерархическая структура доменных имен.
Доменное имя — символьный адрес ресурса в интернете. Иерархия справа налево.
Пример:
Полное имя: www.google.com (или просто google.com)
1.	Корневой домен: . (невидимая точка в конце)
2.	TLD (домен верхнего уровня): .com (коммерческий)
3.	Домен второго уровня (основное имя): google
4.	Поддомен (третий уровень): www — стандартный поддомен для веб-сайта
(support.google.com — служба поддержки)
41.	Понятие хостинга. Виды хостинга.
Хостинг — это услуга по предоставлению вычислительных мощностей и ресурсов для размещения информации на сервере, постоянно находящемся в сети Интернет. 
Виды хостинга: 
Виртуальный хостинг (Shared Hosting) Самый простой и дешевый вид. Множество веб-сайтов располагаются на одном физическом сервере и делят его ресурсы (процессорное время, оперативную память). Подходит для небольших проектов и визиток. 
VPS (Virtual Private Server — Виртуальный выделенный сервер) Технология, при которой на одном физическом сервере создается несколько изолированных виртуальных машин. В отличие от виртуального хостинга, здесь пользователю выделяются гарантированные ресурсы (RAM, CPU), которые не зависят от нагрузки соседей. 
Выделенный сервер (Dedicated Server) Пользователь арендует физический сервер целиком. Все ресурсы машины принадлежат только одному клиенту. Это обеспечивает максимальную производительность и полный контроль над настройками сервера. 
Облачный хостинг (Cloud Hosting) Ресурсы предоставляются не одним сервером, а сетью связанных серверов («облаком»). Если один сервер выходит из строя, нагрузку берет на себя другой. Это обеспечивает высокую надежность и легкую масштабируемость (можно быстро добавить мощность). 

42.	Алгоритм размещения ресурса на GitHub. Сервис Pages.
Последовательность действий:
1. Подготовка проекта локально:
   - Создать папку проекта с файлами: index.html, другие HTML-страницы
   - Добавить папки css/, js/, images/ с соответствующими файлами
2. Создание репозитория на GitHub:
   - Зайти на github.com, авторизоваться
   - Нажать + → New repository
   - Ввести имя репозитория (например, my-project)
   - Сделать репозиторий Public     
3. Включение GitHub Pages:
   - В репозитории на GitHub перейти: Settings → Pages
   - В разделе Branch выбрать ветку main и папку /(root)
   - Нажать Save

4. Доступ к сайту:
   - Через 1-2 минуты сайт будет доступен по адресу:
     - https://username.github.io/my-project/

5. Добавление SEO-файлов:
   - Создать robots.txt с директивами для поисковых роботов
   - Создать sitemap.xml со списком страниц сайта
   - Загрузить их в репозиторий:

6. Обновление сайта:
   - После любых изменений в локальных файлах:
     git add .
     git commit -m "Update content"
     git push origin main
   - Изменения автоматически опубликуются через 1-2 минуты

43.	Базовые принципы работы поисковых систем: краулинг, индексация, ранжирование.
Работа поисковой системы состоит из трех этапов:
1.	Краулинг: Поисковый робот (паук) переходит по ссылкам и скачивает содержимое веб-страниц.
2.	Индексация: Анализ скачанных страниц, извлечение текста и мета-данных, сохранение в базе данных (индексе). Часто используется инвертированный индекс (похож на алфавитный указатель в конце книги). Также используется «Префиксное дерево» — это способ хранения слов, который экономит память, не дублируя одинаковые начала слов (префиксы), и позволяет быстро находить результаты по первым буквам (запрос jav* найдет и Java, и JavaScript).

3.	Ранжирование: Сортировка найденных страниц по степени соответствия запросу пользователя (релевантности).
44.	Внутренние факторы, влияющие на ранжирование ресурсов.
Факторы, контролируемые владельцем сайта: 
Технические (скорость загрузки, адаптивность, валидность кода, HTTPS). Контентные (релевантность, уникальность, ключевые слова в заголовках и мета-тегах). 
Структурные (логичные URL, навигация, внутренние ссылки). Качество контента и юзабилити влияют на поведенческие метрики.
45.	Назначение файла robots.txt. Основные директивы для поисковых роботов.
robots.txt — текстовый файл в корне сайта, содержащий инструкции для поисковых роботов о том, какие разделы не следует сканировать. 
Основные директивы :
•	User-agent: — определяет, к какому роботу относится правило.
•	Disallow: — запрещает сканирование пути.
•	Allow: — разрешает сканирование (приоритет выше Disallow).
•	Sitemap: — указывает путь к файлу карты сайта.

46.	Назначение файла sitemap.xml. Основные теги и их назначение.
Sitemap.xml помогает поисковым роботам находить и индексировать все важные страницы сайта. 
Основные теги: urlset (контейнер), url (информация об одной странице), loc (URL страницы), lastmod (дата изменения), changefreq (частота изменений), priority (приоритет страницы).
47.	Сервисы технического аудита ресурсов. Основные метрики и категории оценки.
Для аудита используются сервисы PageSpeed Insights и Lighthouse. Основные метрики (Core Web Vitals):
•	LCP: Скорость загрузки основного контента (считается хорошим, если контент виден быстрее 2.5 секунд)
•	INP: Время отклика на взаимодействие.
•	CLS: Визуальная стабильность (смещения макета) - оценивает, «прыгает» ли верстка при загрузке. Если кнопки сдвигаются во время загрузки и пользователь случайно нажимает не туда — это плохой показатель CLS.
•	FCP: Первая отрисовка контента.
•	TTFB: Время до получения первого байта от сервера. Категории диагностики: Performance (производительность), Accessibility (доступность), Best Practices (лучшие практики), SEO.

48.	Понятие семантического ядра сайта. Значение. Этапы построения семантического ядра.
Семантическое ядро — структурированный набор поисковых запросов по тематике сайта. 
Значение: основа SEO, позволяет понимать аудиторию, распределять контент и привлекать целевой трафик. 
Этапы: 
1. Сбор запросов (инструменты, конкуренты). 
2. Чистка (удаление дублей, нерелевантных запросов). 
3. Кластеризация (группировка запросов по смыслу). 
4. Распределение (назначение кластеров страницам сайта).
49.	Классификация запросов в семантическом ядре по типам, частотности и гео-привязки. Операторы запросов. Смежные запросы. Кластеризация запросов.
Типы запросов: Информационные (поиск информации), Коммерческие (готовность купить), Навигационные (поиск бренда/сайта), Общие.
Частотность: Высокочастотные (ВЧ), Среднечастотные (СЧ), Низкочастотные (НЧ).
Гео-привязка: Зависимые (с указанием города) и независимые.
Операторы запросов (Yandex Wordstat): "" (точная фраза), ! (точная форма слова), + (учет предлогов), - (исключение слов), [] (порядок слов), (|) (варианты) 
Смежные запросы: Тематически связанные фразы, отличающиеся формулировкой (синонимы, сленг).
Кластеризация: Группировка запросов по смыслу и интенту (намерению) пользователя для распределения их по страницам сайта (1 кластер = 1 страница).
50.	SEO-аудит текста. Основные метрики: частотность, тошнота, LSI, водность, удобочитаемость. 
SEO-аудит текста —это комплексный анализ контента веб-страницы с точки зрения его соответствия требованиям поисковых систем и пользователей для достижения максимальной видимости в поисковой выдаче.
Частотность ключевых слов: количество вхождений ключевика в текст (оптимально 1-3%). 
Тошнота: показатель заспамленности (высокая — плохо). 
LSI-слова: смыслово связанные слова, помогающие понять контекст. 
Водность: процент бессмысленных слов и фраз (рекомендуется <40%). Удобочитаемость: оценка простоты восприятия текста (длина предложений, сложность слов).
